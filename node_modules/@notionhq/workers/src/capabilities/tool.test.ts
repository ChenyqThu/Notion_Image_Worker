import {
	afterEach,
	beforeEach,
	describe,
	expect,
	it,
	type Mock,
	vi,
} from "vitest";
import {
	createToolCapability,
	InvalidToolInputError,
	InvalidToolOutputError,
	ToolExecutionError,
} from "./tool.js";

describe("Worker.tool", () => {
	let stdoutSpy: Mock<typeof process.stdout.write>;

	beforeEach(() => {
		stdoutSpy = vi
			.spyOn(process.stdout, "write")
			.mockImplementation(() => true);
	});

	afterEach(() => {
		vi.restoreAllMocks();
	});

	it("sync execution", async () => {
		const capability = createToolCapability<{ name: string }, string>(
			"sayHello",
			{
				title: "Say Hello",
				description: "Greet a user",
				schema: {
					type: "object",
					properties: {
						name: { type: "string" },
					},
					required: ["name"],
					additionalProperties: false,
				},
				execute: (input: { name: string }) => {
					return `Hello, ${input.name}!`;
				},
			},
		);

		const result = await capability.handler({ name: "Alice" });

		expect(result).toEqual({ _tag: "success", value: "Hello, Alice!" });

		expect(stdoutSpy).toHaveBeenCalledWith(
			`\n<output>"Hello, Alice!"</output>\n`,
		);
	});

	it("async execution", async () => {
		const capability = createToolCapability<{ id: number }, { data: string }>(
			"fetchData",
			{
				title: "Fetch Data",
				description: "Fetch data asynchronously",
				schema: {
					type: "object",
					properties: {
						id: { type: "number" },
					},
					required: ["id"],
					additionalProperties: false,
				},
				execute: async (input: { id: number }) => {
					// Simulate async operation
					await new Promise((resolve) => setTimeout(resolve, 10));
					return { data: `Data for ID ${input.id}` };
				},
			},
		);

		const result = await capability.handler({ id: 42 });

		expect(result).toEqual({
			_tag: "success",
			value: { data: "Data for ID 42" },
		});

		expect(stdoutSpy).toHaveBeenCalledWith(
			`\n<output>{"data":"Data for ID 42"}</output>\n`,
		);
	});

	it("execution error", async () => {
		const capability = createToolCapability<Record<string, never>, string>(
			"throwError",
			{
				title: "Throw Error",
				description: "Throws an error",
				schema: {
					type: "object",
					properties: {},
					required: [],
					additionalProperties: false,
				},
				execute: () => {
					throw new Error("Something went wrong");
				},
			},
		);

		const result = (await capability.handler({})) as {
			_tag: "error";
			error: ToolExecutionError;
		};

		expect(result._tag).toBe("error");
		expect(result.error).toBeInstanceOf(ToolExecutionError);
		expect(result.error.message).toBe("Something went wrong");

		expect(stdoutSpy).toHaveBeenCalledWith(
			`\n<output>{"_tag":"error","error":{"name":"ToolExecutionError","message":"Something went wrong"}}</output>\n`,
		);
	});

	it("invalid input", async () => {
		const capability = createToolCapability<{ name: string }, string>(
			"sayHelloStrict",
			{
				title: "Say Hello",
				description: "Requires a name property",
				schema: {
					type: "object",
					properties: {
						name: { type: "string" },
					},
					required: ["name"],
					additionalProperties: false,
				},
				execute: (input: { name: string }) => {
					return `Hello, ${input.name}!`;
				},
			},
		);

		const result = (await capability.handler({ age: 25 })) as {
			_tag: "error";
			error: InvalidToolInputError;
		};

		expect(result._tag).toBe("error");
		expect(result.error).toBeInstanceOf(InvalidToolInputError);
		expect(result.error.message).toContain("name");

		expect(stdoutSpy).toHaveBeenCalledWith(
			expect.stringContaining(
				`\n<output>{"_tag":"error","error":{"name":"InvalidToolInputError"`,
			),
		);
	});

	it("invalid output", async () => {
		const capability = createToolCapability<
			Record<string, never>,
			{ result: string }
		>("invalidOutput", {
			title: "Return Invalid Output",
			description: "Returns output that doesn't match schema",
			schema: {
				type: "object",
				properties: {},
				required: [],
				additionalProperties: false,
			},
			outputSchema: {
				type: "object",
				properties: {
					result: { type: "string" },
				},
				required: ["result"],
				additionalProperties: false,
			},
			// @ts-expect-error Testing invalid output - intentionally returning number instead of string
			execute: () => {
				return { result: 123 };
			},
		});

		const result = (await capability.handler({})) as {
			_tag: "error";
			error: InvalidToolOutputError;
		};

		expect(result._tag).toBe("error");
		expect(result.error).toBeInstanceOf(InvalidToolOutputError);
		expect(result.error.message).toContain("result");

		expect(stdoutSpy).toHaveBeenCalledWith(
			expect.stringContaining(
				`\n<output>{"_tag":"error","error":{"name":"InvalidToolOutputError"`,
			),
		);
	});

	it("rejects schema where required is missing properties", () => {
		expect(() =>
			createToolCapability<{ name: string; age: number }, string>("bad", {
				title: "Bad",
				description: "Missing required",
				schema: {
					type: "object",
					properties: {
						name: { type: "string" },
						age: { type: "number" },
					},
					required: ["name"],
					additionalProperties: false,
				} as never,
				execute: () => "",
			}),
		).toThrow(/properties \[age\] must be listed in "required"/);
	});

	it("rejects nested schema where required is missing properties", () => {
		expect(() =>
			createToolCapability<{ user: { name: string; email: string } }, string>(
				"bad",
				{
					title: "Bad",
					description: "Nested missing required",
					schema: {
						type: "object",
						properties: {
							user: {
								type: "object",
								properties: {
									name: { type: "string" },
									email: { type: "string" },
								},
								required: ["name"],
								additionalProperties: false,
							} as never,
						},
						required: ["user"],
						additionalProperties: false,
					},
					execute: () => "",
				},
			),
		).toThrow(/at properties\.user.*properties \[email\]/);
	});

	it("accepts schema with nullable (string | null) properties", () => {
		const capability = createToolCapability<
			{ name: string; nickname: string | null },
			string
		>("nullable", {
			title: "Nullable",
			description: "Has nullable properties",
			schema: {
				type: "object",
				properties: {
					name: { type: "string" },
					nickname: {
						anyOf: [{ type: "string" }, { type: "null" }],
					},
				},
				required: ["name", "nickname"],
				additionalProperties: false,
			},
			execute: ({ name, nickname }) => `${name} (${nickname ?? "no nickname"})`,
		});

		expect(capability.config.schema).toBeDefined();
	});

	it("rejects output schema where required is missing properties", () => {
		expect(() =>
			createToolCapability<
				Record<string, never>,
				{ result: string; count: number }
			>("bad", {
				title: "Bad",
				description: "Output missing required",
				schema: {
					type: "object",
					properties: {},
					required: [],
					additionalProperties: false,
				},
				outputSchema: {
					type: "object",
					properties: {
						result: { type: "string" },
						count: { type: "number" },
					},
					required: ["result"],
					additionalProperties: false,
				} as never,
				execute: () => ({ result: "", count: 0 }),
			}),
		).toThrow(/properties \[count\] must be listed in "required"/);
	});

	it("invalid output with custom output schema", async () => {
		const capability = createToolCapability<
			{ value: number },
			{ doubled: number; message: string }
		>("customOutput", {
			title: "Custom Output",
			description: "Has custom output schema",
			schema: {
				type: "object",
				properties: {
					value: { type: "number" },
				},
				required: ["value"],
				additionalProperties: false,
			},
			outputSchema: {
				type: "object",
				properties: {
					doubled: { type: "number" },
					message: { type: "string" },
				},
				required: ["doubled", "message"],
				additionalProperties: false,
			},
			// @ts-expect-error Testing invalid output - intentionally missing message property
			execute: (input: { value: number }) => {
				return {
					doubled: input.value * 2,
				};
			},
		});

		const result = (await capability.handler({ value: 5 })) as {
			_tag: "error";
			error: InvalidToolOutputError;
		};

		expect(result._tag).toBe("error");
		expect(result.error).toBeInstanceOf(InvalidToolOutputError);
		expect(result.error.message).toContain("message");

		expect(stdoutSpy).toHaveBeenCalledWith(
			expect.stringContaining(
				`\n<output>{"_tag":"error","error":{"name":"InvalidToolOutputError"`,
			),
		);
	});
});
