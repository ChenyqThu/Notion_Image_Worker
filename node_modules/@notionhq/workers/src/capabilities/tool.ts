import { Ajv } from "ajv";
import type { AnyJSONSchema, JSONSchema } from "../json-schema.js";
import type { HandlerOptions, JSONValue } from "../types.js";
import type { CapabilityContext } from "./context.js";
import { createCapabilityContext } from "./context.js";

/**
 * Validates that every object schema in the tree has all its `properties`
 * keys listed in `required`. Both providers require this.
 *
 * Throws a descriptive error at tool registration time (not request time)
 * so the developer sees it immediately.
 */
function validateRequiredProperties(
	schema: AnyJSONSchema,
	path: string = "",
): void {
	if ("type" in schema && schema.type === "object" && "properties" in schema) {
		const propKeys = Object.keys(schema.properties).sort();
		const required = [...(schema.required ?? [])].sort();
		const missing = propKeys.filter((k) => !required.includes(k));
		if (missing.length > 0) {
			throw new Error(
				`Invalid schema${path ? ` at ${path}` : ""}: ` +
					`properties [${missing.join(", ")}] must be listed in "required". ` +
					"Both model providers require all properties to be required. " +
					'Use anyOf with { type: "null" } for optional fields.',
			);
		}

		// Recurse into nested property schemas
		for (const [key, propSchema] of Object.entries(schema.properties)) {
			validateRequiredProperties(
				propSchema as AnyJSONSchema,
				path ? `${path}.properties.${key}` : `properties.${key}`,
			);
		}

		// Recurse into $defs
		if ("$defs" in schema && schema.$defs) {
			for (const [key, defSchema] of Object.entries(schema.$defs)) {
				validateRequiredProperties(
					defSchema,
					path ? `${path}.$defs.${key}` : `$defs.${key}`,
				);
			}
		}
	}

	// Recurse into array items
	if ("type" in schema && schema.type === "array" && "items" in schema) {
		validateRequiredProperties(
			schema.items as AnyJSONSchema,
			path ? `${path}.items` : "items",
		);
	}

	// Recurse into anyOf branches
	if ("anyOf" in schema && Array.isArray(schema.anyOf)) {
		for (let i = 0; i < schema.anyOf.length; i++) {
			validateRequiredProperties(
				schema.anyOf[i] as AnyJSONSchema,
				path ? `${path}.anyOf[${i}]` : `anyOf[${i}]`,
			);
		}
	}
}

export interface ToolConfiguration<
	I extends JSONValue,
	O extends JSONValue = JSONValue,
> {
	title: string;
	description: string;
	schema: JSONSchema<I>;
	outputSchema?: JSONSchema<O>;
	execute: (input: I, context: CapabilityContext) => O | Promise<O>;
}

/**
 * An error returned when the input to a tool doesn't match the input schema.
 */
export class InvalidToolInputError extends Error {
	constructor(message: string) {
		super(message);
		this.name = "InvalidToolInputError";
	}

	toJSON() {
		return {
			name: this.name,
			message: this.message,
		};
	}
}

/**
 * An error returned when the output from a tool doesn't match the output schema.
 */
export class InvalidToolOutputError extends Error {
	constructor(message: string) {
		super(message);
		this.name = "InvalidToolOutputError";
	}

	toJSON() {
		return {
			name: this.name,
			message: this.message,
		};
	}
}

/**
 * An error returned when the tool execution fails.
 */
export class ToolExecutionError extends Error {
	constructor(message: string) {
		super(message);
		this.name = "ToolExecutionError";
	}

	toJSON() {
		return {
			name: this.name,
			message: this.message,
		};
	}
}

export type ToolCapability<
	I extends JSONValue,
	O extends JSONValue = JSONValue,
> = ReturnType<typeof createToolCapability<I, O>>;

/**
 * Creates a capability definition for a tool to be used by an agent.
 *
 * @param config - The configuration for the tool.
 * @returns A capability definition for the tool.
 */
export function createToolCapability<
	I extends JSONValue,
	O extends JSONValue = JSONValue,
>(key: string, config: ToolConfiguration<I, O>) {
	validateRequiredProperties(config.schema as AnyJSONSchema);
	if (config.outputSchema) {
		validateRequiredProperties(config.outputSchema as AnyJSONSchema);
	}

	const ajv = new Ajv();
	const validateInput = ajv.compile(config.schema);
	const validateOutput = config.outputSchema
		? ajv.compile(config.outputSchema)
		: null;

	async function handler(input: JSONValue, options: HandlerOptions): Promise<O>;
	async function handler(input: JSONValue): Promise<
		| {
				_tag: "success";
				value: O;
		  }
		| {
				_tag: "error";
				error:
					| InvalidToolInputError
					| InvalidToolOutputError
					| ToolExecutionError;
		  }
	>;
	async function handler(
		input: JSONValue,
		options?: HandlerOptions,
	): Promise<
		| O
		| {
				_tag: "success";
				value: O;
		  }
		| {
				_tag: "error";
				error:
					| InvalidToolInputError
					| InvalidToolOutputError
					| ToolExecutionError;
		  }
	> {
		if (!validateInput(input)) {
			// ajv resets the "errors" property on each validation call.
			if (validateInput.errors == null) {
				throw new Error(
					"Unexpected: No validation errors after failed validation",
				);
			}

			const error = new InvalidToolInputError(
				JSON.stringify(validateInput.errors, null, 2),
			);

			if (options?.concreteOutput) {
				throw error;
			}

			const result = {
				_tag: "error" as const,
				error,
			};

			process.stdout.write(`\n<output>${JSON.stringify(result)}</output>\n`);

			return result;
		}

		try {
			const capabilityContext = createCapabilityContext();
			const result = await config.execute(input, capabilityContext);
			if (validateOutput && !validateOutput(result)) {
				const error = new InvalidToolOutputError(
					JSON.stringify(validateOutput.errors, null, 2),
				);

				if (options?.concreteOutput) {
					throw error;
				}

				const result = {
					_tag: "error" as const,
					error: new InvalidToolOutputError(
						JSON.stringify(validateOutput.errors, null, 2),
					),
				};

				process.stdout.write(`\n<output>${JSON.stringify(result)}</output>\n`);

				return result;
			}

			if (options?.concreteOutput) {
				return result;
			}

			process.stdout.write(`\n<output>${JSON.stringify(result)}</output>\n`);

			return {
				_tag: "success" as const,
				value: result,
			};
		} catch (err) {
			const error = new ToolExecutionError(
				err instanceof Error ? err.message : String(err),
			);

			if (options?.concreteOutput) {
				throw error;
			}

			const result = {
				_tag: "error" as const,
				error,
			};

			process.stdout.write(`\n<output>${JSON.stringify(result)}</output>\n`);

			return result;
		}
	}

	return {
		_tag: "tool" as const,
		key,
		config: {
			title: config.title,
			description: config.description,
			schema: config.schema,
			outputSchema: config.outputSchema,
		},
		handler,
	};
}
